import type { IncomingMessage } from 'node:http';
import * as crypto from 'crypto';
// When bundled via a bundler supporting the `browser` field, then
// the `undici` module will be replaced with https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API
// for browser contexts. See ./undici-browser.js and ./package.json
import { fetch } from 'undici';
import type { BlobCommandOptions, WithUploadProgress } from './helpers';
import { BlobError, getTokenFromOptionsOrEnv } from './helpers';
import type { CommonCompleteMultipartUploadOptions } from './multipart/complete';
import { createCompleteMultipartUploadMethod } from './multipart/complete';
import { createCreateMultipartUploadMethod } from './multipart/create';
import { createCreateMultipartUploaderMethod } from './multipart/create-uploader';
import type { CommonMultipartUploadOptions } from './multipart/upload';
import { createUploadPartMethod } from './multipart/upload';
import { createPutMethod } from './put';
import type { PutBlobResult } from './put-helpers';

/**
 * Interface for put, upload and multipart upload operations.
 * This type omits all options that are encoded in the client token.
 */
export interface ClientCommonCreateBlobOptions {
  /**
   * Whether the blob should be publicly accessible.
   */
  access: 'public';
  /**
   * Defines the content type of the blob. By default, this value is inferred from the pathname.
   * Sent as the 'content-type' header when downloading a blob.
   */
  contentType?: string;
  /**
   * `AbortSignal` to cancel the running request. See https://developer.mozilla.org/en-US/docs/Web/API/AbortSignal
   */
  abortSignal?: AbortSignal;
}

/**
 * Shared interface for put and multipart operations that use client tokens.
 */
export interface ClientTokenOptions {
  /**
   * A client token that was generated by your server using the `generateClientToken` method.
   */
  token: string;
}

/**
 * Shared interface for put and upload operations.
 * @internal This is an internal interface not intended for direct use by consumers.
 */
interface ClientCommonPutOptions
  extends ClientCommonCreateBlobOptions,
    WithUploadProgress {
  /**
   * Whether to use multipart upload. Use this when uploading large files.
   * It will split the file into multiple parts, upload them in parallel and retry failed parts.
   */
  multipart?: boolean;
}

/**
 * @internal Internal function to validate client token options.
 */
function createPutExtraChecks<
  TOptions extends ClientTokenOptions & ClientCommonCreateBlobOptions,
>(methodName: string) {
  return function extraChecks(options: TOptions) {
    if (!options.token.startsWith('vercel_blob_client_')) {
      throw new BlobError(`${methodName} must be called with a client token`);
    }

    if (
      // @ts-expect-error -- Runtime check for DX.
      options.addRandomSuffix !== undefined ||
      // @ts-expect-error -- Runtime check for DX.
      options.allowOverwrite !== undefined ||
      // @ts-expect-error -- Runtime check for DX.
      options.cacheControlMaxAge !== undefined
    ) {
      throw new BlobError(
        `${methodName} doesn't allow \`addRandomSuffix\`, \`cacheControlMaxAge\` or \`allowOverwrite\`. Configure these options at the server side when generating client tokens.`,
      );
    }
  };
}

/**
 * Options for the client-side put operation.
 */
export type ClientPutCommandOptions = ClientCommonPutOptions &
  ClientTokenOptions;

/**
 * Uploads a file to the blob store using a client token.
 *
 * @param pathname - The pathname to upload the blob to, including the extension. This will influence the URL of your blob.
 * @param body - The content of your blob. Can be a string, File, Blob, Buffer or ReadableStream.
 * @param options - Configuration options including:
 *   - access - (Required) Must be 'public' as blobs are publicly accessible.
 *   - token - (Required) A client token generated by your server using the generateClientTokenFromReadWriteToken method.
 *   - contentType - (Optional) The media type for the blob. By default, it's derived from the pathname.
 *   - multipart - (Optional) Whether to use multipart upload for large files. It will split the file into multiple parts, upload them in parallel and retry failed parts.
 *   - abortSignal - (Optional) AbortSignal to cancel the operation.
 *   - onUploadProgress - (Optional) Callback to track upload progress: onUploadProgress(\{loaded: number, total: number, percentage: number\})
 * @returns A promise that resolves to the blob information, including pathname, contentType, contentDisposition, url, and downloadUrl.
 */
export const put = createPutMethod<ClientPutCommandOptions>({
  allowedOptions: ['contentType'],
  extraChecks: createPutExtraChecks('client/`put`'),
});

/**
 * Options for creating a multipart upload from the client side.
 */
export type ClientCreateMultipartUploadCommandOptions =
  ClientCommonCreateBlobOptions & ClientTokenOptions;

/**
 * Creates a multipart upload. This is the first step in the manual multipart upload process.
 *
 * @param pathname - A string specifying the path inside the blob store. This will be the base value of the return URL and includes the filename and extension.
 * @param options - Configuration options including:
 *   - access - (Required) Must be 'public' as blobs are publicly accessible.
 *   - token - (Required) A client token generated by your server using the generateClientTokenFromReadWriteToken method.
 *   - contentType - (Optional) The media type for the file. If not specified, it's derived from the file extension.
 *   - abortSignal - (Optional) AbortSignal to cancel the operation.
 * @returns A promise that resolves to an object containing:
 *   - key: A string that identifies the blob object.
 *   - uploadId: A string that identifies the multipart upload. Both are needed for subsequent uploadPart calls.
 */
export const createMultipartUpload =
  createCreateMultipartUploadMethod<ClientCreateMultipartUploadCommandOptions>({
    allowedOptions: ['contentType'],
    extraChecks: createPutExtraChecks('client/`createMultipartUpload`'),
  });

/**
 * Creates a multipart uploader that simplifies the multipart upload process.
 * This is a wrapper around the manual multipart upload process that provides a more convenient API.
 *
 * @param pathname - A string specifying the path inside the blob store. This will be the base value of the return URL and includes the filename and extension.
 * @param options - Configuration options including:
 *   - access - (Required) Must be 'public' as blobs are publicly accessible.
 *   - token - (Required) A client token generated by your server using the generateClientTokenFromReadWriteToken method.
 *   - contentType - (Optional) The media type for the file. If not specified, it's derived from the file extension.
 *   - abortSignal - (Optional) AbortSignal to cancel the operation.
 * @returns A promise that resolves to an uploader object with the following properties and methods:
 *   - key: A string that identifies the blob object.
 *   - uploadId: A string that identifies the multipart upload.
 *   - uploadPart: A method to upload a part of the file.
 *   - complete: A method to complete the multipart upload process.
 */
export const createMultipartUploader =
  createCreateMultipartUploaderMethod<ClientCreateMultipartUploadCommandOptions>(
    {
      allowedOptions: ['contentType'],
      extraChecks: createPutExtraChecks('client/`createMultipartUpload`'),
    },
  );

/**
 * @internal Internal type for multipart upload options.
 */
type ClientMultipartUploadCommandOptions = ClientCommonCreateBlobOptions &
  ClientTokenOptions &
  CommonMultipartUploadOptions &
  WithUploadProgress;

/**
 * Uploads a part of a multipart upload.
 * Used as part of the manual multipart upload process.
 *
 * @param pathname - Same value as the pathname parameter passed to createMultipartUpload. This will influence the final URL of your blob.
 * @param body - A blob object as ReadableStream, String, ArrayBuffer or Blob based on these supported body types. Each part must be a minimum of 5MB, except the last one which can be smaller.
 * @param options - Configuration options including:
 *   - access - (Required) Must be 'public' as blobs are publicly accessible.
 *   - token - (Required) A client token generated by your server using the generateClientTokenFromReadWriteToken method.
 *   - uploadId - (Required) A string returned from createMultipartUpload which identifies the multipart upload.
 *   - key - (Required) A string returned from createMultipartUpload which identifies the blob object.
 *   - partNumber - (Required) A number identifying which part is uploaded (1-based index).
 *   - contentType - (Optional) The media type for the blob. By default, it's derived from the pathname.
 *   - abortSignal - (Optional) AbortSignal to cancel the running request.
 *   - onUploadProgress - (Optional) Callback to track upload progress: onUploadProgress(\{loaded: number, total: number, percentage: number\})
 * @returns A promise that resolves to the uploaded part information containing etag and partNumber, which will be needed for the completeMultipartUpload call.
 */
export const uploadPart =
  createUploadPartMethod<ClientMultipartUploadCommandOptions>({
    allowedOptions: ['contentType'],
    extraChecks: createPutExtraChecks('client/`multipartUpload`'),
  });

/**
 * @internal Internal type for completing multipart uploads.
 */
type ClientCompleteMultipartUploadCommandOptions =
  ClientCommonCreateBlobOptions &
    ClientTokenOptions &
    CommonCompleteMultipartUploadOptions;

/**
 * Completes a multipart upload by combining all uploaded parts.
 * This is the final step in the manual multipart upload process.
 *
 * @param pathname - Same value as the pathname parameter passed to createMultipartUpload.
 * @param parts - An array containing all the uploaded parts information from previous uploadPart calls. Each part must have properties etag and partNumber.
 * @param options - Configuration options including:
 *   - access - (Required) Must be 'public' as blobs are publicly accessible.
 *   - token - (Required) A client token generated by your server using the generateClientTokenFromReadWriteToken method.
 *   - uploadId - (Required) A string returned from createMultipartUpload which identifies the multipart upload.
 *   - key - (Required) A string returned from createMultipartUpload which identifies the blob object.
 *   - contentType - (Optional) The media type for the file. If not specified, it's derived from the file extension.
 *   - abortSignal - (Optional) AbortSignal to cancel the operation.
 * @returns A promise that resolves to the finalized blob information, including pathname, contentType, contentDisposition, url, and downloadUrl.
 */
export const completeMultipartUpload =
  createCompleteMultipartUploadMethod<ClientCompleteMultipartUploadCommandOptions>(
    {
      allowedOptions: ['contentType'],
      extraChecks: createPutExtraChecks('client/`completeMultipartUpload`'),
    },
  );

/**
 * Options for client-side upload operations.
 */
export interface CommonUploadOptions {
  /**
   * A route that implements the `handleUpload` function for generating a client token.
   */
  handleUploadUrl: string;
  /**
   * Additional data which will be sent to your `handleUpload` route.
   */
  clientPayload?: string;
  /**
   * Additional headers to be sent when making the request to your `handleUpload` route.
   * This is useful for sending authorization headers or any other custom headers.
   */
  headers?: Record<string, string>;
}

/**
 * Options for the upload method, which handles client-side uploads.
 */
export type UploadOptions = ClientCommonPutOptions & CommonUploadOptions;

/**
 * Uploads a blob into your store from the client.
 * Detailed documentation can be found here: https://vercel.com/docs/vercel-blob/using-blob-sdk#client-uploads
 *
 * If you want to upload from your server instead, check out the documentation for the put operation: https://vercel.com/docs/vercel-blob/using-blob-sdk#upload-a-blob
 *
 * Unlike the put method, this method does not require a client token as it will fetch one from your server.
 *
 * @param pathname - The pathname to upload the blob to. This includes the filename and extension.
 * @param body - The contents of your blob. This has to be a supported fetch body type (string, Blob, File, ArrayBuffer, etc).
 * @param options - Configuration options including:
 *   - access - (Required) Must be 'public' as blobs are publicly accessible.
 *   - handleUploadUrl - (Required) A string specifying the route to call for generating client tokens for client uploads.
 *   - clientPayload - (Optional) A string to be sent to your handleUpload server code. Example use-case: attaching the post id an image relates to.
 *   - headers - (Optional) An object containing custom headers to be sent with the request to your handleUpload route. Example use-case: sending Authorization headers.
 *   - contentType - (Optional) A string indicating the media type. By default, it's extracted from the pathname's extension.
 *   - multipart - (Optional) Whether to use multipart upload for large files. It will split the file into multiple parts, upload them in parallel and retry failed parts.
 *   - abortSignal - (Optional) AbortSignal to cancel the operation.
 *   - onUploadProgress - (Optional) Callback to track upload progress: onUploadProgress(\{loaded: number, total: number, percentage: number\})
 * @returns A promise that resolves to the blob information, including pathname, contentType, contentDisposition, url, and downloadUrl.
 */
export const upload = createPutMethod<UploadOptions>({
  allowedOptions: ['contentType'],
  extraChecks(options) {
    if (options.handleUploadUrl === undefined) {
      throw new BlobError(
        "client/`upload` requires the 'handleUploadUrl' parameter",
      );
    }

    if (
      // @ts-expect-error -- Runtime check for DX.
      options.addRandomSuffix !== undefined ||
      // @ts-expect-error -- Runtime check for DX.
      options.createPutExtraChecks !== undefined ||
      // @ts-expect-error -- Runtime check for DX.
      options.cacheControlMaxAge !== undefined ||
      // @ts-expect-error -- Runtime check for DX.
      options.ifMatch !== undefined
    ) {
      throw new BlobError(
        "client/`upload` doesn't allow `addRandomSuffix`, `cacheControlMaxAge`, `allowOverwrite` or `ifMatch`. Configure these options at the server side when generating client tokens.",
      );
    }
  },
  async getToken(pathname, options) {
    return retrieveClientToken({
      handleUploadUrl: options.handleUploadUrl,
      pathname,
      clientPayload: options.clientPayload ?? null,
      multipart: options.multipart ?? false,
      headers: options.headers,
    });
  },
});

/**
 * @internal Internal function to import a crypto key.
 */
async function importKey(token: string): Promise<CryptoKey> {
  return globalThis.crypto.subtle.importKey(
    'raw',
    new TextEncoder().encode(token),
    { name: 'HMAC', hash: 'SHA-256' },
    false,
    ['sign', 'verify'],
  );
}

/**
 * @internal Internal function to sign a payload.
 */
async function signPayload(
  payload: string,
  token: string,
): Promise<string | undefined> {
  if (!globalThis.crypto) {
    return crypto.createHmac('sha256', token).update(payload).digest('hex');
  }

  const signature = await globalThis.crypto.subtle.sign(
    'HMAC',
    await importKey(token),
    new TextEncoder().encode(payload),
  );
  return Buffer.from(new Uint8Array(signature)).toString('hex');
}

/**
 * @internal Internal function to verify a callback signature.
 */
async function verifyCallbackSignature({
  token,
  signature,
  body,
}: {
  token: string;
  signature: string;
  body: string;
}): Promise<boolean> {
  // callback signature is signed using the server token
  const secret = token;
  // Browsers, Edge runtime and Node >=20 implement the Web Crypto API

  if (!globalThis.crypto) {
    // Node <20 falls back to the Node.js crypto module
    const digest = crypto
      .createHmac('sha256', secret)
      .update(body)
      .digest('hex');
    const digestBuffer = Buffer.from(digest);
    const signatureBuffer = Buffer.from(signature);

    return (
      digestBuffer.length === signatureBuffer.length &&
      crypto.timingSafeEqual(digestBuffer, signatureBuffer)
    );
  }

  const verified = await globalThis.crypto.subtle.verify(
    'HMAC',
    await importKey(token),
    // @ts-expect-error Buffer is compatible with BufferSource at runtime
    hexToArrayByte(signature),
    new TextEncoder().encode(body),
  );
  return verified;
}

/**
 * @internal Internal utility function to convert hex to array byte.
 */
function hexToArrayByte(input: string): Buffer {
  if (input.length % 2 !== 0) {
    throw new RangeError('Expected string to be an even number of characters');
  }
  const view = new Uint8Array(input.length / 2);

  for (let i = 0; i < input.length; i += 2) {
    view[i / 2] = Number.parseInt(input.substring(i, i + 2), 16);
  }

  return Buffer.from(view);
}

/**
 * Decoded payload from a client token.
 */
export type DecodedClientTokenPayload = Omit<
  GenerateClientTokenOptions,
  'token'
> & {
  /**
   * Timestamp in milliseconds when the token will expire.
   */
  validUntil: number;
};

/**
 * Extracts and decodes the payload from a client token.
 *
 * @param clientToken - The client token string to decode
 * @returns The decoded payload containing token options
 */
export function getPayloadFromClientToken(
  clientToken: string,
): DecodedClientTokenPayload {
  const [, , , , encodedToken] = clientToken.split('_');
  const encodedPayload = Buffer.from(encodedToken ?? '', 'base64')
    .toString()
    .split('.')[1];
  const decodedPayload = Buffer.from(encodedPayload ?? '', 'base64').toString();
  return JSON.parse(decodedPayload) as DecodedClientTokenPayload;
}

/**
 * @internal Event type constants for internal use.
 */
const EventTypes = {
  generateClientToken: 'blob.generate-client-token',
  uploadCompleted: 'blob.upload-completed',
} as const;

/**
 * Event for generating a client token for blob uploads.
 * @internal This is an internal interface used by the SDK.
 */
interface GenerateClientTokenEvent {
  /**
   * Type identifier for the generate client token event.
   */
  type: (typeof EventTypes)['generateClientToken'];

  /**
   * Payload containing information needed to generate a client token.
   */
  payload: {
    /**
     * The destination path for the blob.
     */
    pathname: string;

    /**
     * Whether the upload will use multipart uploading.
     */
    multipart: boolean;

    /**
     * Additional data from the client which will be available in onBeforeGenerateToken.
     */
    clientPayload: string | null;
  };
}

/**
 * Event that occurs when a client upload has completed.
 * @internal This is an internal interface used by the SDK.
 */
interface UploadCompletedEvent {
  /**
   * Type identifier for the upload completed event.
   */
  type: (typeof EventTypes)['uploadCompleted'];

  /**
   * Payload containing information about the uploaded blob.
   */
  payload: {
    /**
     * Details about the blob that was uploaded.
     */
    blob: PutBlobResult;

    /**
     * Optional payload that was defined during token generation.
     */
    tokenPayload?: string | null;
  };
}

/**
 * Union type representing either a request to generate a client token or a notification that an upload completed.
 */
export type HandleUploadBody = GenerateClientTokenEvent | UploadCompletedEvent;

/**
 * Type representing either a Node.js IncomingMessage or a web standard Request object.
 * @internal This is an internal type used by the SDK.
 */
type RequestType = IncomingMessage | Request;

/**
 * Options for the handleUpload function.
 */
export interface HandleUploadOptions {
  /**
   * The request body containing upload information.
   */
  body: HandleUploadBody;

  /**
   * Function called before generating the client token for uploads.
   *
   * @param pathname - The destination path for the blob
   * @param clientPayload - A string payload specified on the client when calling upload()
   * @param multipart - A boolean specifying whether the file is a multipart upload
   *
   * @returns An object with configuration options for the client token including the optional callbackUrl
   */
  onBeforeGenerateToken: (
    pathname: string,
    clientPayload: string | null,
    multipart: boolean,
  ) => Promise<
    Pick<
      GenerateClientTokenOptions,
      | 'allowedContentTypes'
      | 'maximumSizeInBytes'
      | 'validUntil'
      | 'addRandomSuffix'
      | 'allowOverwrite'
      | 'cacheControlMaxAge'
      | 'ifMatch'
    > & { tokenPayload?: string | null; callbackUrl?: string }
  >;

  /**
   * Function called by Vercel Blob when the client upload finishes.
   * This is useful to update your database with the blob URL that was uploaded.
   *
   * @param body - Contains information about the completed upload including the blob details
   */
  onUploadCompleted?: (body: UploadCompletedEvent['payload']) => Promise<void>;

  /**
   * A string specifying the read-write token to use when making requests.
   * It defaults to process.env.BLOB_READ_WRITE_TOKEN when deployed on Vercel.
   */
  token?: string;

  /**
   * An IncomingMessage or Request object to be used to determine the action to take.
   */
  request: RequestType;
}

/**
 * A server-side route helper to manage client uploads. It has two responsibilities:
 * 1. Generate tokens for client uploads
 * 2. Listen for completed client uploads, so you can update your database with the URL of the uploaded file
 *
 * @param options - Configuration options for handling uploads
 *   - request - (Required) An IncomingMessage or Request object to be used to determine the action to take.
 *   - body - (Required) The request body containing upload information.
 *   - onBeforeGenerateToken - (Required) Function called before generating the client token for uploads.
 *   - onUploadCompleted - (Optional) Function called by Vercel Blob when the client upload finishes.
 *   - token - (Optional) A string specifying the read-write token to use when making requests. Defaults to process.env.BLOB_READ_WRITE_TOKEN.
 * @returns A promise that resolves to either a client token generation result or an upload completion result
 */
export async function handleUpload({
  token,
  request,
  body,
  onBeforeGenerateToken,
  onUploadCompleted,
}: HandleUploadOptions): Promise<
  | { type: 'blob.generate-client-token'; clientToken: string }
  | { type: 'blob.upload-completed'; response: 'ok' }
> {
  const resolvedToken = getTokenFromOptionsOrEnv({ token });

  const type = body.type;
  switch (type) {
    case 'blob.generate-client-token': {
      const { pathname, clientPayload, multipart } = body.payload;
      const payload = await onBeforeGenerateToken(
        pathname,
        clientPayload,
        multipart,
      );
      const tokenPayload = payload.tokenPayload ?? clientPayload;
      const { callbackUrl: providedCallbackUrl, ...tokenOptions } = payload;
      let callbackUrl = providedCallbackUrl;

      // If onUploadCompleted is provided but no callbackUrl was provided, try to infer it from environment
      if (onUploadCompleted && !callbackUrl) {
        callbackUrl = getCallbackUrl(request);
      }

      // If no onUploadCompleted but callbackUrl was provided, warn about it
      if (!onUploadCompleted && callbackUrl) {
        console.warn(
          'callbackUrl was provided but onUploadCompleted is not defined. The callback will not be handled.',
        );
      }

      // one hour
      const oneHourInSeconds = 60 * 60;
      const now = new Date();
      const validUntil =
        payload.validUntil ??
        now.setSeconds(now.getSeconds() + oneHourInSeconds);

      return {
        type,
        clientToken: await generateClientTokenFromReadWriteToken({
          ...tokenOptions,
          token: resolvedToken,
          pathname,
          onUploadCompleted: callbackUrl
            ? {
                callbackUrl,
                tokenPayload,
              }
            : undefined,
          validUntil,
        }),
      };
    }
    case 'blob.upload-completed': {
      const signatureHeader = 'x-vercel-signature';
      const signature = (
        'credentials' in request
          ? (request.headers.get(signatureHeader) ?? '')
          : (request.headers[signatureHeader] ?? '')
      ) as string;

      if (!signature) {
        throw new BlobError('Missing callback signature');
      }

      const isVerified = await verifyCallbackSignature({
        token: resolvedToken,
        signature,
        body: JSON.stringify(body),
      });

      if (!isVerified) {
        throw new BlobError('Invalid callback signature');
      }

      if (onUploadCompleted) {
        await onUploadCompleted(body.payload);
      }
      return { type, response: 'ok' };
    }
    default:
      throw new BlobError('Invalid event type');
  }
}

/**
 * @internal Internal function to retrieve a client token from server.
 */
async function retrieveClientToken(options: {
  pathname: string;
  handleUploadUrl: string;
  clientPayload: string | null;
  multipart: boolean;
  abortSignal?: AbortSignal;
  headers?: Record<string, string>;
}): Promise<string> {
  const { handleUploadUrl, pathname } = options;
  const url = isAbsoluteUrl(handleUploadUrl)
    ? handleUploadUrl
    : toAbsoluteUrl(handleUploadUrl);

  const event: GenerateClientTokenEvent = {
    type: EventTypes.generateClientToken,
    payload: {
      pathname,
      clientPayload: options.clientPayload,
      multipart: options.multipart,
    },
  };

  const res = await fetch(url, {
    method: 'POST',
    body: JSON.stringify(event),
    headers: {
      'content-type': 'application/json',
      ...options.headers,
    },
    signal: options.abortSignal,
  });

  if (!res.ok) {
    throw new BlobError('Failed to  retrieve the client token');
  }

  try {
    const { clientToken } = (await res.json()) as { clientToken: string };
    return clientToken;
  } catch {
    throw new BlobError('Failed to retrieve the client token');
  }
}

/**
 * @internal Internal utility to convert a relative URL to absolute URL.
 */
function toAbsoluteUrl(url: string): string {
  // location is available in web workers too: https://developer.mozilla.org/en-US/docs/Web/API/Window/location
  return new URL(url, location.href).href;
}

/**
 * @internal Internal utility to check if a URL is absolute.
 */
function isAbsoluteUrl(url: string): boolean {
  try {
    return Boolean(new URL(url));
  } catch {
    return false;
  }
}

/**
 * Generates a client token from a read-write token. This function must be called from a server environment.
 * The client token contains permissions and constraints that limit what the client can do.
 *
 * @param options - Options for generating the client token
 *   - pathname - (Required) The destination path for the blob.
 *   - token - (Optional) A string specifying the read-write token to use. Defaults to process.env.BLOB_READ_WRITE_TOKEN.
 *   - onUploadCompleted - (Optional) Configuration for upload completion callback.
 *   - maximumSizeInBytes - (Optional) A number specifying the maximum size in bytes that can be uploaded (max 5TB).
 *   - allowedContentTypes - (Optional) An array of media types that are allowed to be uploaded. Wildcards are supported (text/*).
 *   - validUntil - (Optional) A timestamp in ms when the token will expire. Defaults to one hour from generation.
 *   - addRandomSuffix - (Optional) Whether to add a random suffix to the filename. Defaults to false.
 *   - allowOverwrite - (Optional) Whether to allow overwriting existing blobs. Defaults to false.
 *   - cacheControlMaxAge - (Optional) Number of seconds to configure cache duration. Defaults to one month.
 *   - ifMatch - (Optional) Only write if the ETag matches (optimistic concurrency control).
 * @returns A promise that resolves to the generated client token string which can be used in client-side upload operations.
 */
export async function generateClientTokenFromReadWriteToken({
  token,
  ...argsWithoutToken
}: GenerateClientTokenOptions): Promise<string> {
  if (typeof window !== 'undefined') {
    throw new BlobError(
      '"generateClientTokenFromReadWriteToken" must be called from a server environment',
    );
  }

  const timestamp = new Date();
  timestamp.setSeconds(timestamp.getSeconds() + 30);
  const readWriteToken = getTokenFromOptionsOrEnv({ token });

  const [, , , storeId = null] = readWriteToken.split('_');

  if (!storeId) {
    throw new BlobError(
      token ? 'Invalid `token` parameter' : 'Invalid `BLOB_READ_WRITE_TOKEN`',
    );
  }

  const payload = Buffer.from(
    JSON.stringify({
      ...argsWithoutToken,
      validUntil: argsWithoutToken.validUntil ?? timestamp.getTime(),
    }),
  ).toString('base64');

  const securedKey = await signPayload(payload, readWriteToken);

  if (!securedKey) {
    throw new BlobError('Unable to sign client token');
  }
  return `vercel_blob_client_${storeId}_${Buffer.from(
    `${securedKey}.${payload}`,
  ).toString('base64')}`;
}

/**
 * Options for generating a client token.
 */
export interface GenerateClientTokenOptions extends BlobCommandOptions {
  /**
   * The destination path for the blob
   */
  pathname: string;

  /**
   * Configuration for upload completion callback
   */
  onUploadCompleted?: {
    callbackUrl: string;
    tokenPayload?: string | null;
  };

  /**
   * A number specifying the maximum size in bytes that can be uploaded. The maximum is 5TB.
   */
  maximumSizeInBytes?: number;

  /**
   * An array of strings specifying the media type that are allowed to be uploaded.
   * By default, it's all content types. Wildcards are supported (text/*)
   */
  allowedContentTypes?: string[];

  /**
   * A number specifying the timestamp in ms when the token will expire.
   * By default, it's now + 1 hour.
   */
  validUntil?: number;

  /**
   * Adds a random suffix to the filename.
   * @defaultvalue false
   */
  addRandomSuffix?: boolean;

  /**
   * Allow overwriting an existing blob. By default this is set to false and will throw an error if the blob already exists.
   * @defaultvalue false
   */
  allowOverwrite?: boolean;

  /**
   * Number in seconds to configure how long Blobs are cached. Defaults to one month. Cannot be set to a value lower than 1 minute.
   * @defaultvalue 30 * 24 * 60 * 60 (1 Month)
   */
  cacheControlMaxAge?: number;

  /**
   * Only write if the ETag matches (optimistic concurrency control).
   * Use this for conditional writes to prevent overwriting changes made by others.
   * If the ETag doesn't match, a `BlobPreconditionFailedError` will be thrown.
   */
  ifMatch?: string;
}

/**
 * @internal Helper function to determine the callback URL for client uploads
 * when onUploadCompleted is provided but no callbackUrl was specified
 */
function getCallbackUrl(request: RequestType): string | undefined {
  const reqPath = getPathFromRequestUrl(request.url!);

  if (!reqPath) {
    console.warn(
      'onUploadCompleted provided but no callbackUrl could be determined. Please provide a callbackUrl in onBeforeGenerateToken or set the VERCEL_BLOB_CALLBACK_URL environment variable.',
    );
    return undefined;
  }

  // Check if we have VERCEL_BLOB_CALLBACK_URL env var (works on or off Vercel)
  if (process.env.VERCEL_BLOB_CALLBACK_URL) {
    return `${process.env.VERCEL_BLOB_CALLBACK_URL}${reqPath}`;
  }

  // Not hosted on Vercel and no VERCEL_BLOB_CALLBACK_URL
  if (process.env.VERCEL !== '1') {
    console.warn(
      'onUploadCompleted provided but no callbackUrl could be determined. Please provide a callbackUrl in onBeforeGenerateToken or set the VERCEL_BLOB_CALLBACK_URL environment variable.',
    );
    return undefined;
  }

  // If hosted on Vercel, generate default callbackUrl

  if (process.env.VERCEL_ENV === 'preview') {
    if (process.env.VERCEL_BRANCH_URL) {
      return `https://${process.env.VERCEL_BRANCH_URL}${reqPath}`;
    }
    if (process.env.VERCEL_URL) {
      return `https://${process.env.VERCEL_URL}${reqPath}`;
    }
  }

  if (
    process.env.VERCEL_ENV === 'production' &&
    process.env.VERCEL_PROJECT_PRODUCTION_URL
  ) {
    return `https://${process.env.VERCEL_PROJECT_PRODUCTION_URL}${reqPath}`;
  }

  return undefined;
}

/**
 * @internal Helper function to safely extract pathname and query string from request URL
 * Handles both full URLs (http://localhost:3000/api/upload?test=1) and relative paths (/api/upload?test=1)
 */
function getPathFromRequestUrl(url: string): string | null {
  try {
    // Using dummy.com as base URL to handle relative paths
    const parsedUrl = new URL(url, 'https://dummy.com');
    return parsedUrl.pathname + parsedUrl.search;
  } catch {
    return null;
  }
}

export { createFolder } from './create-folder';
