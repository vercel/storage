{"version":3,"sources":["../scripts/postinstall.ts","../src/utils/parse-connection-string.ts"],"sourcesContent":["/// <reference types=\"node\" />\n\n// This script runs uncombiled with \"node --experimental-strip-types\",\n// so all imports need to use \".ts\"\n\n/*\n * Reads all connected Edge Configs and emits them to the stores folder\n * that can be accessed at runtime by the mockable-import function.\n *\n * Attaches the updatedAt timestamp from the header to the emitted file, since\n * the endpoint does not currently include it in the response body.\n */\nimport { mkdir, writeFile } from 'node:fs/promises';\nimport { dirname, join } from 'node:path';\nimport { fileURLToPath } from 'node:url';\nimport type { Connection, EmbeddedEdgeConfig } from '../src/types';\nimport { parseConnectionString } from '../src/utils/parse-connection-string';\n\n// Get the directory where this CLI script is located\nconst __filename = fileURLToPath(import.meta.url);\nconst __dirname = dirname(__filename);\n\ntype StoresJson = Record<\n  string,\n  {\n    data: EmbeddedEdgeConfig;\n    updatedAt: number | undefined;\n  }\n>;\n\n// Write to the stores.json file of the package itself\nconst getOutputPath = (): string => {\n  // During development: packages/edge-config/stores.json\n  // When installed: node_modules/@vercel/edge-config/stores.json\n  return join(__dirname, '..', 'dist', 'stores.json');\n};\n\nasync function main(): Promise<void> {\n  if (process.env.EDGE_CONFIG_SKIP_BUILD_EMBEDDING === '1') return;\n\n  const connections = Object.values(process.env).reduce<Connection[]>(\n    (acc, value) => {\n      if (typeof value !== 'string') return acc;\n      const data = parseConnectionString(value);\n      if (data) acc.push(data);\n      return acc;\n    },\n    [],\n  );\n\n  const outputPath = getOutputPath();\n\n  const values = await Promise.all(\n    connections.map(async (connection) => {\n      const res = await fetch(connection.baseUrl, {\n        headers: {\n          authorization: `Bearer ${connection.token}`,\n          // consistentRead\n          'x-edge-config-min-updated-at': `${Number.MAX_SAFE_INTEGER}`,\n        },\n      });\n\n      const ts = res.headers.get('x-edge-config-updated-at');\n      const data: EmbeddedEdgeConfig = await res.json();\n      return { data, updatedAt: ts ? Number(ts) : undefined };\n    }),\n  );\n\n  const stores = connections.reduce<StoresJson>((acc, connection, index) => {\n    const value = values[index];\n    acc[connection.id] = value;\n    return acc;\n  }, {});\n\n  // Ensure the dist directory exists before writing\n  await mkdir(dirname(outputPath), { recursive: true });\n  await writeFile(outputPath, JSON.stringify(stores));\n  // eslint-disable-next-line no-console -- This is a CLI tool\n  if (Object.keys(stores).length === 0) {\n    console.error(`@vercel/edge-config: Embedded no stores`);\n  } else {\n    console.log(\n      `@vercel/edge-config: Embedded ${Object.keys(stores).join(', ')}`,\n    );\n  }\n}\n\nmain().catch((error) => {\n  // eslint-disable-next-line no-console -- This is a CLI tool\n  console.error('@vercel/edge-config: postinstall failed', error);\n  process.exit(1);\n});\n","import type { Connection } from '../types';\n\n/**\n * Parses internal edge config connection strings\n *\n * Internal edge config connection strings are those which are native to Vercel.\n *\n * Internal Edge Config Connection Strings look like this:\n * https://edge-config.vercel.com/<edgeConfigId>?token=<token>\n */\nfunction parseVercelConnectionStringFromUrl(text: string): Connection | null {\n  try {\n    const url = new URL(text);\n    if (url.host !== 'edge-config.vercel.com') return null;\n    if (url.protocol !== 'https:') return null;\n    if (!url.pathname.startsWith('/ecfg')) return null;\n\n    const id = url.pathname.split('/')[1];\n    if (!id) return null;\n\n    const token = url.searchParams.get('token');\n    if (!token || token === '') return null;\n\n    return {\n      type: 'vercel',\n      baseUrl: `https://edge-config.vercel.com/${id}`,\n      id,\n      version: '1',\n      token,\n    };\n  } catch {\n    return null;\n  }\n}\n\n/**\n * Parses a connection string with the following format:\n * `edge-config:id=ecfg_abcd&token=xxx`\n */\nfunction parseConnectionFromQueryParams(text: string): Connection | null {\n  try {\n    if (!text.startsWith('edge-config:')) return null;\n    const params = new URLSearchParams(text.slice(12));\n\n    const id = params.get('id');\n    const token = params.get('token');\n\n    if (!id || !token) return null;\n\n    return {\n      type: 'vercel',\n      baseUrl: `https://edge-config.vercel.com/${id}`,\n      id,\n      version: '1',\n      token,\n    };\n  } catch {\n    // no-op\n  }\n\n  return null;\n}\n\n/**\n * Parses info contained in connection strings.\n *\n * This works with the vercel-provided connection strings, but it also\n * works with custom connection strings.\n *\n * The reason we support custom connection strings is that it makes testing\n * edge config really straightforward. Users can provide  connection strings\n * pointing to their own servers and then either have a custom server\n * return the desired values or even intercept requests with something like\n * msw.\n *\n * To allow interception we need a custom connection string as the\n * edge-config.vercel.com connection string might not always go over\n * the network, so msw would not have a chance to intercept.\n */\n/**\n * Parses external edge config connection strings\n *\n * External edge config connection strings are those which are foreign to Vercel.\n *\n * External Edge Config Connection Strings look like this:\n * - https://example.com/?id=<edgeConfigId>&token=<token>\n * - https://example.com/<edgeConfigId>?token=<token>\n */\nfunction parseExternalConnectionStringFromUrl(\n  connectionString: string,\n): Connection | null {\n  try {\n    const url = new URL(connectionString);\n\n    let id: string | null = url.searchParams.get('id');\n    const token = url.searchParams.get('token');\n    const version = url.searchParams.get('version') || '1';\n\n    // try to determine id based on pathname if it wasn't provided explicitly\n    if (!id || url.pathname.startsWith('/ecfg_')) {\n      id = url.pathname.split('/')[1] || null;\n    }\n\n    if (!id || !token) return null;\n\n    // remove all search params for use as baseURL\n    url.search = '';\n\n    // try to parse as external connection string\n    return {\n      type: 'external',\n      baseUrl: url.toString(),\n      id,\n      token,\n      version,\n    };\n  } catch {\n    return null;\n  }\n}\n\n/**\n * Parse the edgeConfigId and token from an Edge Config Connection String.\n *\n * Edge Config Connection Strings usually look like one of the following:\n *  - https://edge-config.vercel.com/<edgeConfigId>?token=<token>\n *  - edge-config:id=<edgeConfigId>&token=<token>\n *\n * @param text - A potential Edge Config Connection String\n * @returns The connection parsed from the given Connection String or null.\n */\nexport function parseConnectionString(\n  connectionString: string,\n): Connection | null {\n  return (\n    parseConnectionFromQueryParams(connectionString) ||\n    parseVercelConnectionStringFromUrl(connectionString) ||\n    parseExternalConnectionStringFromUrl(connectionString)\n  );\n}\n"],"mappings":"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","names":[]}